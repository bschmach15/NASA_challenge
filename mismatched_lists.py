import os

def mismatch_lists(table1,table2):
    """This function will check to make sure Send and Receive logs from MPI reports match"""
    """ASSUMPTIONS: table1 and table2 are DataFrames from Pandas package
                    table1 and table2 have been sorted numerically by sender
                    (if you used file_import this will have bene taken care of)
                    table1 and table 2 have corresponding column names
                    The first column in table1 and table1 details the sender"""

    """This function will take in your send logs and receive logs in DataFrames generated by the function
    file_import. It will then search through each sender node for a matching receiving node. If a match is found
    it is noted, for both tables. After both tables have been  searched, each match is removed
    from the table, leaving only the processes without a sender or receiver.
    These nodes are then stored to a .log file."""

    """When prompted for a file path, please provide the entire path (Include C:\Users\... in your path"""



    # retrieves how many rows and columns there are in each table
    row1, row2, col1 = len(table1.axes[0]), len(table2.axes[0]),len(table1.axes[1])

    #retrieves the names of the columns and stores them in a list
    col_list = table1.columns.tolist()

    #Retrieves how many times a specific process sent a message
    tab1val = table1[col_list[0]].value_counts(sort=False)
    #Retrieves how many messages are expected from each process
    tab2val = table2[col_list[0]].value_counts(sort=False)

    #determines number of send processes
    table1.index = range(0, row1)
    #determines number of receive processes
    table2.index = range(0, row2)

    #Compares amount of sends to how many sends are expected from each process
    #Processes that sent more than were received, or processes that sent less messages than
    #were expected are marked False
    truth_tab = tab2val == tab1val

    #where we will store unmatched send processes
    err_tab_send = table1
    #where we will store unmatched receive processes
    err_tab_recv = table2
    #where we will store the index for matched send processes
    send_match_list = []
    #where we will store the index for matched receive processes
    rec_match_list = []

    #where we start comparing in send list
    start_count1 = 0
    #where we start comparing in receive list
    start_count2 = 0
    for p in range(0,len(tab1val)):
        #if the process sends the expected amount of messages, we will not
        #check it for a missing process
        if truth_tab.loc[p] == True:
            #mark every index in this range as matched for both send and
            #recieve processes
            print "All messages sent from process", p,"are accounted for"
            for i in range(start_count1,tab1val.loc[p]+start_count1):
                send_match_list.append(i)
            for i in range(start_count2,tab2val.loc[p]+start_count2):
                rec_match_list.append(i)
            #update the starting index to check the next process
            start_count1 += tab1val.loc[p]
            start_count2 += tab2val.loc[p]
            continue
            #an example would be if there are 42 messages expected from process 0
            #and process 0 sent 42 messages, we would mark every index with a 0
            #in the send column as matched, and then move on to check the same criteria
            #for the 1 processes
        #if there was a mismatch between the amount of expected sends from a particular process
        #and the amount that process sent, we will search for it

        #We take the slice of our tables that contain the process we are curious about
        #we are only interested in indexes with '1' in the "Sender" column, for example,
        #so we slice our table accordingly

        print "There are unmatched processes here in process",p
        print "I will look for them"
        tab1temp = table1.iloc[start_count1:tab1val.loc[p]+start_count1]
        tab2temp = table2.iloc[start_count2:tab2val.loc[p]+start_count2]

        for i in range(start_count1,tab1val.loc[p]+start_count1):
            if i % 100 == 0: print i #make sure there were no hiccups and the program is running
            for j in range(start_count2,tab2val.loc[p]+start_count2):
                unequal = False #flag for flow control
                equal = False #flag for flow control
                for k in range(1,col1):
                    #here we are simply checking each column in the ith row of table 1
                    #and the jth row of table 2.
                    if tab1temp.loc[i][col_list[k]] == tab2temp.loc[j][col_list[k]]:
                        if k == col1-1:
                            #if a match is found and we have just checked the last column,
                            #we check to see if that index has already been found as to avoid
                            #double counting
                            if i not in send_match_list and j not in rec_match_list:
                                #we make note of the matching indices for both tables
                                send_match_list.append(i)
                                rec_match_list.append(j)
                                #and flag that we've found an equality
                                equal = True
                            else:
                                #if we have already marked one or the other as equal, move on
                                continue
                        else:
                            #if we are not on the last column, keep checking subsequent columns for matches
                            continue
                    elif j == tab2val.loc[p]+start_count2-1:
                        #if we have checked the last row and failed to find any matching rows
                        #flag unequal
                        unequal = True
                        break
                    else:
                        #if the one of the columns doesn't match, check the next row in table2
                        break
                if equal == True:
                    #if a match is found in row j, move onto the next i row
                    #this way we don't keep searching the rest of table2
                    break
                if unequal == True:
                    #if there was no match, say so and move onto matching the next row in table1
                    print "There were no matches for row ", i
                    break
        #once we've found each match, we update our index and move onto the next process
        start_count1 += tab1val.loc[p]
        start_count2 += tab2val.loc[p]

    #after finding all the matches, we delete them from our error tables using the indices
    #noted above
    #What we are left with is two DataFrames containing the unmatched processes
    for i in send_match_list:
         err_tab_send = err_tab_send.drop(i)
        #in this DataFrame, we have processes that were sending, but had nothing receiving
    for i in rec_match_list:
        #and here we had processes ready to receive but nothing sending
        err_tab_recv = err_tab_recv.drop(i)

    #output reports to .log file
    path = raw_input("Where would you  like to save this file? Please provide the path to the directory")
    file_name = raw_input("What would you like to name this file (no file extenions)?")
    complete_name = os.path.join(path,file_name+".log")
    x = open(complete_name,'w')
    x.write("The number of messages each node is sending:"+"\n")
    tab1val.to_csv(x,sep="|")
    x.write("The number of nodes expecting a message from each sender:"+"\n")
    tab2val.to_csv(x,sep="|")
    x.write("Sending nodes without a process to receive them:"+"\n")
    err_tab_send.to_csv(x,sep='|',index=False)
    x.write("Receiving nodes waiting for data with no process to send it:"+"\n")
    err_tab_recv.to_csv(x,sep='|',index=False)
    x.close()

    print "Done. Your log with the unmatched processes is waiting at", complete_name
    #return DataFrames to python for inspection if so desired
    return err_tab_send, err_tab_recv
